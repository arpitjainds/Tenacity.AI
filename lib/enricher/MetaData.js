
/*
* Copyright 2016 IBM Corp. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
const sttUtils = require('./STTDataUtils');
const log = require('pino')();
// Used for the relevance calculation for generating the automatic tags.
const defaultRelevance = '0.7';

// This defines the metadata structure we use that is generated by the Enricher
const watsonEnrichment = {
  speaker: '',
  tags: [],
  transcript: '', // text enrichment calculated from
  visual_recognition: [],
  start_time: '',
  end_time: '', // time of enrichment
  concepts: [], // raw_data, timeline: [ array of when concepts occurred ]},
  entities: [],
  categories: [],
  docSentiment: [],
  docEmotions: [],
  typedRelations: [],
  keywords: [],
  extended_keywords: [],
  document_tone: [],
  sentences_tone: [],
  visualSentiment: '',
  keyFrames: [],
  visualTags: [],
  soundEmotion: [],
  raw_stt_results: [],
};

const isRelevant = (obj, limit) => {
  // Some obj w/ 'relevance' on it
  const relevance = (limit) || defaultRelevance;
  return (obj.relevance) ? parseFloat(obj.relevance) > parseFloat(relevance) : false;
};

// Remove similar items
// const cleanTags = (array) => {
//
// };

// Look for the times tags occurred
const populateOccurrenceTimes = (array, data) =>
  // console.log('1: ', array);
    array.map((a) => {
      const obj = {};
   // console.log('2: ', a);
      obj[a] = sttUtils.findEntityTime(a, data);
      return obj;
    });

// This is where we get our tags
// Returns an array of tags that match.
const getTags = (alchemyArray, relevance) =>
  // Alchemy array has objects w/ a 'text' field we are returning
   alchemyArray
    .filter(obj => isRelevant(obj, relevance))
    .map((obj) => {
      const value = obj.text ? obj.text : obj.label;
      return value;
    });

const generateTags = (data) => {
  // Couple of things here:
  //
  // 1.  Get better Tags -- Endities does not have a 'relevance' (or may not), categories is 'score'
  // 2.  Scrub for duplicates
  // 3.  If we we had the 'time' we should match back to that.

  const tagSources = {
    'entities': '0.5',
    'categories': '0.1',
    'concepts': '0.5',
    'keywords': '0.9',
  };

  // Step 1, pull the Entities...
  //
  const tags = Object.keys(tagSources).map(key =>
    // Return the gettags for the key
     getTags(data[key], tagSources[key])).reduce((a, b) => a.concat(b));
  return tags;
};

class MetaData {
  constructor(data) {
//    console.log(data);
    log.info('enrichment Metadata DATA? ', data);
    this.data = Object.assign({}, watsonEnrichment);
    if (data.hasOwnProperty('text')) {
      // this is our data
      this.data.transcript = data.text;
      // The begin and end time of our text we are enriching comes from the STT_data or begin/end
      // If STT Data, override w/ it.
      if (data.hasOwnProperty('stt_data')) {
//        log.info('STT_DATA? ', data.stt_data);
        this.data.raw_stt_results = data.stt_data;
        this.data.start_time = sttUtils.getStartTime(this.data.raw_stt_results);
        this.data.end_time = sttUtils.getEndTime(this.data.raw_stt_results);
        if (data.speakerTimeline && data.speakerTimeline.length === 0) {
          this.data.speakerTimeline =
            sttUtils.generateTranscriptTimeline(this.data.raw_stt_results);
          log.info('enricher MetaData -> Creating speakerTimeline: ', this.data.speakerTimeline);
        }
      } else {
        if (data.hasOwnProperty('begin')) {
          this.data.start_time = data.begin;
          this.data.end_time = data.end;
        }
        if (data.hasOwnProperty('speakerTimeline')) {
          this.data.speakerTimeline = data.speakerTimeline;
        }
      }
    } else if (data.hasOwnProperty('transcript')) {
      // this is full data, probably for testing, cast it:
      console.log('----------------- transcript ------------------');
      Object.assign(this.data, data);
      this.data.start_time = data.begin ?
        data.begin :
        sttUtils.getStartTime(this.data.raw_stt_results);
      this.data.end_time = data.end ? data.end : sttUtils.getEndTime(this.data.raw_stt_results);
      if (data.hasOwnProperty('speakerTimeline')) {
        this.data.speakerTimeline = data.speakerTimeline;
      }
    } else {
      console.log('Doing nothing...');
    }
  }

  getSpeakerTimeline() {
    return this.data.speakerTimeline;
  }

  getData() {
    return this.data;
  }
  apply(obj) {
    if (obj) {
      Object.assign(this.data, obj);
    }
    this.data.tags = populateOccurrenceTimes(generateTags(this.data), this.data.raw_stt_results);
  }
}
module.exports = MetaData;
